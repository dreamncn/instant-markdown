<html>
    <head>
        <title>Instant Markdown</title>
        <style>
            :root {
                --format-width: 50pt;
                --format-color: #80808099;
                --highlight-section-color: #057EAE11;
                --highlight-line-color: #057EAE33;
                --heading-border-color: #80808033;
                --quote-border-color: #80808099;
                --hr-color: #80808033;
            }


            textarea:focus {
                outline: none;
            }
            .hidden {
                display: none !important;
            }


            #display, #input, #settings {
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
            }
            #input {
                opacity: .01;
            }


            #display div, #display p , #display ul, #display ol, #display li {
                margin: 0;
                padding: 0;
            }

            #display span.left {
                display: inline-block;
                width: var(--format-width);
                color: var(--format-color);
            }
            #display span.right {
                display: inline-block;
                box-sizing: border-box;
            }
            #display :not(li) > span.right {
                width: calc(100% - var(--format-width));
            }
            #display li > span.right {
                width: 100%;
            }
            #display span.right:after {
                content: '';
                display: inline-block;
                height: 1em;
            }

            #display .current {
                background: var(--highlight-section-color);
            }
            #display .current .current {
                background: var(--highlight-line-color);
            }

            #display .h1 p:first-child,
            #display .h2 p:first-child,
            #display .h3 p:first-child,
            #display .h4 p:first-child,
            #display .h5 p:first-child,
            #display .h6 p:first-child {
                font-weight: bold;
                margin-bottom: 5pt;
            }
            #display .h1 p:first-child {
                font-size: 200%;
                margin-top: 20pt;
                border-bottom: 1px solid var(--heading-border-color);
            }
            #display .h2 p:first-child {
                font-size: 160%;
                margin-top: 15pt;
                border-bottom: 1px solid var(--heading-border-color);
            }
            #display .h3 p:first-child, #display .h4 p:first-child, #display .h5 p:first-child, #display .h6 p:first-child {
                margin-top: 10pt;
            }
            #display .h3 p:first-child {
                font-size: 140%;
            }
            #display .h4 p:first-child {
                font-size: 130%;
            }
            #display .h5 p:first-child {
                font-size: 120%;
            }
            #display .h6 p:first-child {
                font-size: 110%;
            }

            #display .quote span.right {
                border-left: 1px solid var(--quote-border-color);
                padding-left: 10pt;
            }

            #display .ul {
                margin-left: calc(var(--format-width) + 12pt);
            }
            #display .ul li span.left {
                position: absolute;
                left: 0;
            }
            #display .ul li span.right {
                padding-left: 10pt;
            }

            #display .hr div span.right::after {
                content: ' ';
                width: 100%;
                height: 0;
                vertical-align: middle;
                border-bottom: 1px solid var(--hr-color);
            }


            #start-info {
                display: inline-block;
                position: relative;
                top: 50%;
                transform: translateY(-50%);
                width: 100%;
                text-align: center;
                font-style: italic;
            }
            #start-info h1 {
                color: #0001;
                font-size: 10vw;
            }
            #start-info p {
                padding: 10pt 0;
            }


            #settings {
                backdrop-filter: blur(2pt);
                background-color: #fffd;

                display: flex;
                flex-direction: column;
                padding: 10%;
            }
            #settings h2 {
                text-align: center;
                font-size: 200%;
                color: gray;
            }
            #settings textarea {
                flex-grow: 1;

                padding: 20pt;
                border: 1px solid #80808033;
                box-shadow: 3pt 3pt 10pt #80808066;
            }
            #controls-info {
                margin-top: 20pt;
            }
            #controls-info p {
                margin: 5pt 0 0;
            }
            #controls-info p.more {
                margin-top: 0;
            }
            #controls-info span {
                display: inline-block;
                width: 70pt;
                font-weight: bold;
                vertical-align: top;
            }
        </style>
        <script>
            let fileTypeDialogOption = { types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md'] } }] };
            let formats = {
                default:{ multiline: true },
                h1:     { pattern: /^(#)($|\s+(.*)$)/ },
                h2:     { pattern: /^(##)($|\s+(.*)$)/ },
                h3:     { pattern: /^(###)($|\s+(.*)$)/ },
                h4:     { pattern: /^(####)($|\s+(.*)$)/ },
                h5:     { pattern: /^(#####)($|\s+(.*)$)/ },
                h6:     { pattern: /^(######)($|\s+(.*)$)/ },
                quote:  { pattern: /^(>)($|\s*(.*)$)/, multiline: true, outerTag: 'div' },
                ul:     { pattern: /^(-|\*)($|\s+(.*)$)/, multiline: true, listItem: true, outerTag: 'ul', innerTag: 'li' },
                hr:     { pattern: /^(---)()$/, innerTag: 'div' }
            };
            for (let f in formats) {
                formats[f] = Object.assign({ matchL: 1, matchR: 2, className: f, innerTag: 'p' }, formats[f]);
            }
            let formats_all = Object.values(formats);
            let formats_singleline = formats_all.filter(f => !f.multiline);
            let formats_listItem = formats_all.filter(f => f.listItem);

            let input = null;
            let display = null;
            let startInfo = null;
            let settings = null;
            let settingsInput = null;

            let docTitle = document.title;
            let customStyle = null;
            let currentFileHandle = null;
            let fileChanged = false;

            let sections = [];

            let cookies = Object.assign({}, ...document.cookie.split(';').map(c => { c = c.split('='); return { [c[0].trim()]: decodeURIComponent(c[1]) }; }));

            function init()
            {
                input = document.querySelector('#input');
                display = document.querySelector('#display');
                startInfo = document.querySelector('#start-info');
                settings = document.querySelector('#settings');
                settingsInput = settings.querySelector('textarea');

                // editor
                ['click', 'focus', 'select', 'keydown', 'keyup'].forEach(evt => input.addEventListener(evt, updateSelection));
                input.addEventListener('input', e => { fileChanged = true; updateMarkdown(); });
                updateMarkdown();
                display.addEventListener('click', e =>
                {
                    input.focus();
                });
                input.focus();

                // load/save local files
                let warningMsg = 'Changes to the current document will be lost.';
                document.addEventListener('dragover', e => e.preventDefault());
                document.addEventListener('drop', async e =>
                {
                    e.preventDefault();
                    if (fileChanged && !confirm(warningMsg + ' Proceed to open the dropped file?'))
                        return;
                    if (e.dataTransfer.items.length > 1) {
                        alert('Only a single file can be loaded.');
                        return;
                    }
                    let dataItem = e.dataTransfer.items[0];
                    if (dataItem.kind === 'file') {
                        currentFileHandle = await dataItem.getAsFileSystemHandle();
                        loadFile();
                    }
                });
                document.addEventListener('keydown', async e =>
                {
                    if (e.ctrlKey) {
                        switch (e.key.toLowerCase()) {
                            case 'o':
                                e.preventDefault();
                                if (fileChanged && !confirm(warningMsg + ' Proceed to open another file?'))
                                    return;
                                [currentFileHandle] = await window.showOpenFilePicker(fileTypeDialogOption);
                                loadFile();
                            break;
                            case 's':
                                e.preventDefault();
                                saveFile();
                            break;
                            case 'n':
                            case 'q':
                                e.preventDefault();
                                if (fileChanged && !confirm(warningMsg + ' Proceed to start a new file?'))
                                    return;
                                reset();
                                updateMarkdown();
                            break;
                            default:
                        }
                    }
                    if (e.key.toLowerCase() === 'escape') {
                        e.preventDefault();
                        toggleSettings();
                    }
                });
                window.addEventListener('beforeunload', e => {
                    if (fileChanged) {
                        e.preventDefault();
                        let msg = warningMsg + ' Close ' + docTitle + '?';
                        (e || window.event).returnValue = msg;
                        return msg;
                    }
                });

                // settings
                customStyle = new CSSStyleSheet();
                document.adoptedStyleSheets = [customStyle];
                if ('customStyle' in cookies)
                    settingsInput.value = cookies.customStyle;
                else {
                    let style = document.styleSheets[0].cssRules[0].styleMap;
                    let defaultStyle = '';
                    for (let key of style.keys()) {
                        defaultStyle += key + ':' + style.get(key) + ';\n';
                    }
                    settingsInput.value = defaultStyle;
                }
                settingsInput.addEventListener('input', e => {
                    applyCustomStyle();
                });
                applyCustomStyle();
            }
            function applyCustomStyle()
            {
                customStyle.replace(':root{' + settingsInput.value + '}');
            }
            function reset(clearFileHandle = true)
            {
                input.value = '';
                display.innerHTML = '';
                startInfo.classList.add('hidden');
                if (clearFileHandle) {
                    currentFileHandle = null;
                    document.title = docTitle;
                }
                fileChanged = false;
            }
            function toggleSettings()
            {
                settings.classList.toggle('hidden');
                if (!settings.classList.contains('hidden')) {
                    settingsInput.focus();
                }
                else {
                    document.cookie = 'customStyle=' + encodeURIComponent(settingsInput.value);
                }
            }
            async function loadFile()
            {
                if (currentFileHandle.kind !== 'file') {
                    currentFileHandle = null;
                    alert('Only files can be loaded.');
                    return;
                }
                if (!currentFileHandle.name.endsWith('.md')) {
                    currentFileHandle = null;
                    alert('Only Markdown (.md) files can be loaded.');
                    return;
                }
                console.log('try to load file: ' + currentFileHandle.name);
                let file = await currentFileHandle.getFile();
                let reader = new FileReader();
                reader.addEventListener('load', () => {
                    reset(false);
                    document.title = currentFileHandle.name + ' • ' + docTitle;
                    input.value = reader.result;
                    updateMarkdown();
                    console.log('file loaded: ' + currentFileHandle.name);
                }, false);
                reader.readAsText(file);
            }
            async function saveFile()
            {
                if (!currentFileHandle) {
                    currentFileHandle = await window.showSaveFilePicker(fileTypeDialogOption);
                    if (!currentFileHandle) {
                        return;
                    }
                }
                let writableStream = await currentFileHandle.createWritable();
                await writableStream.write(input.value);
                await writableStream.close();
                fileChanged = false;
                document.title = currentFileHandle.name + ' • ' + docTitle;
                console.log('file saved: ' + currentFileHandle.name);
            }
            function updateMarkdown()
            {
                display.innerHTML = '';

                if (input.value.length)
                    startInfo.classList.add('hidden');
                else {
                    startInfo.classList.remove('hidden');
                    return;
                }

                sections = [];
                let position = 0;
                let newSection = values => Object.assign({ pos: position, outerPos: position, format: formats.default, innerContent: [], outerContent: [] }, values);
                let lines = input.value.split('\n');

                // if (e.inputType === 'insertLineBreak') {}

                // parse input text
                let startNewSection = true;
                lines.forEach(line =>
                {
                    let nextPosition = position + 1 + line.length;
                    line = { pos: position, text: line, left: '', right: line };

                    // empty line
                    if (line.text.trim() === '') {
                        if (!sections.length)
                            sections.push(newSection({ outerContent: [line] }));
                        else
                            sections.last().outerContent.push(line);
                        startNewSection = true;
                    }
                    else {
                        let lineFormatMatch = getLineFormat(line.text);
                        line.left = lineFormatMatch.matchL;
                        line.right = lineFormatMatch.matchR;
                        let prevSection = sections.length ? sections.last() : null;
                        let prevFormat = prevSection ? prevSection.format : null;
                        // formatted
                        if (lineFormatMatch.format !== formats.default) {
                            let sameAsPrevious = prevFormat && prevFormat === lineFormatMatch.format && !prevSection.outerContent.length;
                            if (lineFormatMatch.format.listItem && sameAsPrevious) {
                                prevSection.innerContent.push([line]);
                                startNewSection = false;
                            }
                            else if (lineFormatMatch.format.multiline && sameAsPrevious) {
                                prevSection.innerContent.push([line]);
                                startNewSection = false;
                            }
                            else {
                                sections.push(newSection({ format: lineFormatMatch.format, innerContent: [[line]] }));
                                startNewSection = formats_singleline.includes(lineFormatMatch.format);
                            }
                        }
                        // plain text
                        else {
                            if (prevFormat && prevFormat.listItem && !prevSection.outerContent.length)
                                prevSection.innerContent.last().push(line);
                            else if (startNewSection)
                                sections.push(newSection({ innerContent: [[line]] }));
                            else
                                sections.last().innerContent.push([line]);
                            startNewSection = false;
                        }
                        sections.last().outerPos = nextPosition;
                    }
                    position = nextPosition;
                });
                console.log(sections);

                // generate HTML
                sections.forEach(section =>
                {
                    let format = section.format;
                    section.htmlTag = document.createElement('div');
                    section.htmlTag.classList.add(format.className);

                    if (section.innerContent.length) {
                        let container = section.htmlTag;
                        if (format.outerTag) {
                            container = document.createElement(format.outerTag);
                            section.htmlTag.appendChild(container);
                        }
                        for (let c in section.innerContent) {
                            let lines = section.innerContent[c];
                            let tag = document.createElement(format.innerTag);
                            for (let l in lines) {
                                let line = lines[l];
                                let spanLeft = document.createElement('span');
                                spanLeft.classList.add('left');
                                spanLeft.innerHTML = line.left;
                                tag.appendChild(spanLeft);
                                let spanRight = document.createElement('span');
                                spanRight.classList.add('right');
                                spanRight.innerHTML = line.right;
                                tag.appendChild(spanRight);
                                line.htmlTag = spanRight;
                            }
                            container.appendChild(tag);
                            section.innerContent[c] = { lines: lines, htmlTag: tag, pos: lines[0].pos };
                        }
                    }
                    if (section.outerContent.length) {
                        for (let c in section.outerContent) {
                            let line = section.outerContent[c];
                            let tag = document.createElement(formats.default.innerTag);
                                let span = document.createElement('span');
                                span.classList.add('right');
                                span.innerHTML = line.text;
                                tag.appendChild(span);
                                line.htmlTag = span;
                            section.htmlTag.appendChild(tag);
                            section.outerContent[c] = { lines: [line], htmlTag: tag, pos: line.pos };
                        }
                    }
                    display.appendChild(section.htmlTag);
                });
                updateSelection();
            }
            function updateSelection()
            {
                if (!input.value.length)
                    return;

                document.querySelectorAll('.current').forEach(el => el.classList.remove('current'));

                let cursorPos = input.selectionStart;
                let selection = {};

                for (let s in sections) {
                    let section = sections[s];
                    if (section.pos > cursorPos) {
                        selection.section = sections[s - 1];
                        break;
                    }
                }
                if (!selection.section)
                    selection.section = sections.last();
                selection.section.htmlTag.classList.add('current');

                if (selection.section.outerPos > cursorPos) {
                    for (let c in selection.section.innerContent) {
                        let ic = selection.section.innerContent[c];
                        if (ic.pos > cursorPos) {
                            selection.lines = selection.section.innerContent[c - 1];
                            break;
                        }
                    }
                    if (!selection.lines)
                        selection.lines = selection.section.innerContent.last();
                    selection.lines.htmlTag.classList.add('current');
                }
                else {
                    for (let c in selection.section.outerContent) {
                        let oc = selection.section.outerContent[c];
                        if (oc.pos > cursorPos) {
                            selection.lines = selection.section.outerContent[c - 1];
                            break;
                        }
                    }
                    if (!selection.lines)
                        selection.lines = selection.section.outerContent.last();
                    selection.lines.htmlTag.classList.add('current');
                }
            }
            function getLineFormat(line, formatsToCheck = null)
            {
                let check = (line, format) =>
                    (format.match === line)
                        || (format.start
                            && (format.start === line
                                || line.startsWith(format.start + ' ')
                                || line.startsWith(format.start + '\xa0')
                                || line.startsWith(format.start + '&nbsp;')));

                let formatsArray = formatsToCheck || formats_all;
                for (let i in formatsArray) {
                    let format = formatsArray[i];
                    if (format.pattern) {
                        let match = line.match(format.pattern);
                        if (match)
                            return { format: format, matchL: match[format.matchL], matchR: match[format.matchR] };
                    }
                }
                return formatsToCheck ? null : { format: formats.default, matchL: '', matchR: line };
            }
            Object.defineProperty(Array.prototype, 'last', {
                value: function() { return this.length ? this[this.length - 1] : null; },
                enumerable: false
            });
        </script>
    </head>
    <body onload="init()">
        <div id="start-info" class="hidden">
            <p>Just start typing</p>
            <p>or press Ctrl+O or drop a file you want to edit</p>
            <p>or press Esc for settings</p>
            <h1>Instant Markdown</h1>
        </div>
        <textarea id="input"></textarea>
        <div id="display"></div>
        <div id="settings" class="hidden">
            <h2>Settings</h2>
            <textarea></textarea>
            <div id="controls-info">
                <p><span>Ctrl + O</span>Open a markdown file</p>
                <p><span>Ctrl + S</span>Save a markdown file</p>
                <p><span>Ctrl + Q</span>Start a fresh markdown file</p>
                <p class="more"><span>Ctrl + N</span>(only avilable in app mode)</p>
                <p><span>Escape</span>Toggle settings</p>
            </div>
        </div>
    </body>
</html>