<html>
    <head>
        <title>Instant Markdown</title>
        <style>
            :root {
                --format-width: 50pt;
                --format-color: gray;
                --highlight-section-color: #ff05;
                --highlight-line-color: #fa05;
            }

            #display, #input {
                position: absolute;
                left: 0;
                top: 0;
                right: 0;
                bottom: 0;
            }
            #input {
                opacity: .01;
            }


            #display div, #display p , #display ul, #display ol, #display li {
                margin: 0;
                padding: 0;
            }

            #display i {
                display: inline-block;
                width: var(--format-width);
                color: var(--format-color);
            }
            #display span {
                display: inline-block;
                box-sizing: border-box;
            }
            #display :not(li) > span {
                width: calc(100% - var(--format-width));
            }
            #display li > span {
                width: 100%;
            }
            #display span:after {
                content: '';
                display: inline-block;
                height: 1em;
            }

            #display .current {
                background: var(--highlight-section-color);
            }
            #display .current .current {
                background: var(--highlight-line-color);
            }

            #display .h1 p:first-child {
                font-size: 200%;
                font-weight: bold;
                margin-top: 20pt;
                margin-bottom: 5pt;
                border-bottom: 1px solid #ccc;
            }
            #display .h2 p:first-child {
                font-size: 160%;
                font-weight: bold;
                margin-top: 10pt;
                margin-bottom: 4pt;
                border-bottom: 1px solid #eee;
            }
            #display .h3 p:first-child {
                font-size: 140%;
                font-weight: bold;
                margin-top: 5pt;
                margin-bottom: 4pt;
            }

            #display .quote span {
                border-left: 1px solid gray;
                padding-left: 10pt;
            }

            #display .ul {
                margin-left: calc(var(--format-width) + 12pt);
            }
            #display .ul li i {
                position: absolute;
                left: 0;
            }
            #display .ul li span {
                padding-left: 10pt;
            }

            #display .hr {
                display: flex;
            }
            #display .hr::after {
                content: ' ';
                border-bottom: 1px solid gray;
                flex-grow: 1;
                height: 0.6em;
                margin-left: 10pt;
            }
        </style>
        <script>
            let formats = {
                default:{ multiline: true },
                h1:     { start: '#' },
                h2:     { start: '##' },
                h3:     { start: '###' },
                quote:  { start: '>', multiline: true, outerTag: 'div' },
                ul:     { start: '-', multiline: true, listItem: true, outerTag: 'ul', innerTag: 'li' },
                hr:     { match: '---' }
            };

            let input = null;
            let display = null;
            for (let f in formats) {
                formats[f] = Object.assign({ className: f, innerTag: 'p' }, formats[f]);
            }
            let formats_all = Object.values(formats);
            let formats_singleline = formats_all.filter(f => !f.multiline);
            let formats_listItem = formats_all.filter(f => f.listItem);

            let sections = [];
            function init()
            {
                input = document.querySelector('#input');
                display = document.querySelector('#display');
                ['click', 'focus', 'select', 'keyup'].forEach(evt => input.addEventListener(evt, updateSelection));
                input.addEventListener('input', updateMarkdown);
                updateMarkdown();
            }
            function updateMarkdown()
            {
                sections = [];
                let position = 0;
                let newSection = values => Object.assign({ pos: position, outerPos: position, format: formats.default, innerContent: [], outerContent: [] }, values);
                let lines = input.value.split('\n');

                // if (e.inputType === 'insertLineBreak') {}

                // parse input text
                let startNewSection = true;
                lines.forEach(line =>
                {
                    let nextPosition = position + 1 + line.length;
                    line = { pos: position, text: line };

                    // empty line
                    if (line.text.trim() === '') {
                        if (!sections.length)
                            sections.push(newSection({ outerContent: [line] }));
                        else
                            sections.last().outerContent.push(line);
                        startNewSection = true;
                    }
                    else {
                        let format = getLineFormat(line.text);
                        let prevSection = sections.length ? sections.last() : null;
                        let prevFormat = prevSection ? prevSection.format : null;
                        // formatted
                        if (format !== formats.default) {
                            if (format.listItem && prevFormat && prevFormat.listItem)
                                prevSection.innerContent.push([line]);
                            else
                                sections.push(newSection({ format: format, innerContent: [[line]] }));
                            startNewSection = !!getLineFormat(line.text, formats_singleline);
                        }
                        // plain text
                        else {
                            if (prevFormat && prevFormat.listItem && !prevSection.outerContent.length)
                                prevSection.innerContent.last().push(line);
                            else if (startNewSection)
                                sections.push(newSection({ innerContent: [[line]] }));
                            else
                                sections.last().innerContent.push([line]);
                            startNewSection = false;
                        }
                        sections.last().outerPos = nextPosition;
                    }
                    position = nextPosition;
                });
                console.log(sections);

                // generate HTML
                display.innerHTML = '';
                sections.forEach(section =>
                {
                    let format = section.format;
                    section.htmlTag = document.createElement('div');
                    section.htmlTag.className = format.className;

                    if (section.innerContent.length) {
                        let container = section.htmlTag;
                        if (format.outerTag) {
                            container = document.createElement(format.outerTag);
                            section.htmlTag.appendChild(container);
                        }
                        for (let c in section.innerContent) {
                            let lines = section.innerContent[c];
                            let tag = document.createElement(format.innerTag);
                            for (let l in lines) {
                                let line = lines[l];
                                let fat = splitFormatAndText(line.text, format);
                                let i = document.createElement('i');
                                i.innerHTML = fat.format;
                                tag.appendChild(i);
                                let span = document.createElement('span');
                                span.innerHTML = fat.text;
                                tag.appendChild(span);
                                line.htmlTag = span;
                            }
                            container.appendChild(tag);
                            section.innerContent[c] = { lines: lines, htmlTag: tag, pos: lines[0].pos };
                        }
                    }
                    if (section.outerContent.length) {
                        for (let c in section.outerContent) {
                            let line = section.outerContent[c];
                            let tag = document.createElement(formats.default.innerTag);
                                let span = document.createElement('span');
                                span.innerHTML = line.text;
                                tag.appendChild(span);
                                line.htmlTag = span;
                            section.htmlTag.appendChild(tag);
                            section.outerContent[c] = { lines: [line], htmlTag: tag, pos: line.pos };
                        }
                    }
                    display.appendChild(section.htmlTag);
                });
                updateSelection();
            }
            function updateSelection()
            {
                document.querySelectorAll('.current').forEach(el => el.classList.remove('current'));

                let cursorPos = input.selectionStart;
                let selection = {};

                for (let s in sections) {
                    let section = sections[s];
                    if (section.pos > cursorPos) {
                        selection.section = sections[s - 1];
                        break;
                    }
                }
                if (!selection.section)
                    selection.section = sections.last();
                selection.section.htmlTag.classList.add('current');

                if (selection.section.outerPos > cursorPos) {
                    for (let c in selection.section.innerContent) {
                        let ic = selection.section.innerContent[c];
                        if (ic.pos > cursorPos) {
                            selection.lines = selection.section.innerContent[c - 1];
                            break;
                        }
                    }
                    if (!selection.lines)
                        selection.lines = selection.section.innerContent.last();
                    selection.lines.htmlTag.classList.add('current');
                }
                else {
                    for (let c in selection.section.outerContent) {
                        let oc = selection.section.outerContent[c];
                        if (oc.pos > cursorPos) {
                            selection.lines = selection.section.outerContent[c - 1];
                            break;
                        }
                    }
                    if (!selection.lines)
                        selection.lines = selection.section.outerContent.last();
                    selection.lines.htmlTag.classList.add('current');
                }
            }
            function getLineFormat(line, formatsToCheck = null)
            {
                let check = (line, format) =>
                    (format.match === line)
                        || (format.start
                            && (format.start === line
                                || line.startsWith(format.start + ' ')
                                || line.startsWith(format.start + '\xa0')
                                || line.startsWith(format.start + '&nbsp;')));

                let formatsArray = formatsToCheck || formats_all;
                for (let i in formatsArray) {
                    if (check(line, formatsArray[i]))
                        return formatsArray[i];
                }
                return formatsToCheck ? null : formats.default;
            }
            function splitFormatAndText(line, format)
            {
                if (format.match === line || format.start === line )
                    return { format: line, text: '' };
                if (format.start)
                    for (let ws of [' ', '\xa0', '&nbsp;'])
                        if (line.startsWith(format.start + ws))
                            return { format: format.start, text: line.substr(format.start.length + ws.length) };
                return { format: '', text: line };
            }
            Object.defineProperty(Array.prototype, 'last', {
                value: function() { return this.length ? this[this.length - 1] : null; },
                enumerable: false
            });
        </script>
    </head>
    <body onload="init()"><div id="display"></div><textarea id="input">Start here...</textarea></body>
</html>