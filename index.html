<html>
    <head>
        <title>Instant Markdown</title>
        <style>
            :root {
                --format-width: 50pt;
                --line-format-color: #80808099;
                --inline-format-color: #80808099;

                --highlight-section-color: transparent;
                --highlight-item-color: transparent;
                --highlight-line-color: #057EAE22;
                --highlight-inline-part-color: transparent;

                --heading-border-color: #80808033;
                --quote-border-color: #80808099;
                --code-border-color: #80808022;
                --hr-color: #80808033;
            }


            textarea:focus {
                outline: none;
            }
            .hidden {
                display: none !important;
            }


            #display, #input, #settings {
                left: 0;
                top: 0;
            }
            #display {
                position: absolute;
                right: 0;
            }
            #input, #settings {
                position: fixed;
                right: 0;
                bottom: 0;
            }
            #input {
                opacity: 0;
            }
            #settings {
                overflow-y: auto;
            }


            #display div, #display p , #display ul, #display ol, #display li {
                margin: 0;
                padding: 0;
            }

            #display span.left {
                display: inline-block;
                width: var(--format-width);
                color: var(--line-format-color);
            }
            #display span.right {
                display: inline-block;
                box-sizing: border-box;
            }
            #display :not(li) > span.right {
                width: calc(100% - var(--format-width));
            }
            #display li > span.right {
                width: 100%;
            }
            #display span.right:after {
                content: '';
                display: inline-block;
                height: 1em;
            }

            #display .current {
                background: var(--highlight-section-color);
            }
            #display .current .current {
                background: var(--highlight-item-color);
            }
            #display .current .current .current {
                background: var(--highlight-line-color);
            }
            #display .current .current .current .current {
                background: var(--highlight-inline-part-color);
            }

            #display .h1 p:first-child,
            #display .h2 p:first-child,
            #display .h3 p:first-child,
            #display .h4 p:first-child,
            #display .h5 p:first-child,
            #display .h6 p:first-child {
                font-weight: bold;
                margin-bottom: 5pt;
            }
            #display .h1 p:first-child {
                font-size: 200%;
                margin-top: 20pt;
                border-bottom: 1px solid var(--heading-border-color);
            }
            #display .h2 p:first-child {
                font-size: 160%;
                margin-top: 15pt;
                border-bottom: 1px solid var(--heading-border-color);
            }
            #display .h3 p:first-child, #display .h4 p:first-child, #display .h5 p:first-child, #display .h6 p:first-child {
                margin-top: 10pt;
            }
            #display .h3 p:first-child {
                font-size: 140%;
            }
            #display .h4 p:first-child {
                font-size: 130%;
            }
            #display .h5 p:first-child {
                font-size: 120%;
            }
            #display .h6 p:first-child {
                font-size: 110%;
            }

            #display .quote div span.right {
                border-left: 1px solid var(--quote-border-color);
                padding-left: 15pt;
            }

            #display .code code span.right {
                border-left: 1px solid var(--code-border-color);
                border-right: 1px solid var(--code-border-color);
                padding: 0 5pt;
                background: #80808011;
            }
            #display .code code p:first-child span.right {
                color: var(--inline-format-color);
            }
            #display .code code p:first-child span.right,
            #display .code code p:last-child span.right {
                border: none;
                padding: 0;
                background: none;
            }
            #display .code code p:nth-child(2) span.right {
                border-top: 1px solid var(--code-border-color);
                padding-top: 5pt;
            }
            #display .code code p:nth-last-child(2) span.right {
                border-bottom: 1px solid var(--code-border-color);
                padding-bottom: 5pt;
            }

            #display .ul ul {
                margin-left: calc(var(--format-width) + 12pt);
            }
            #display .ul li span.left {
                position: absolute;
                left: 0;
            }
            #display .ul li span.right {
                padding-left: 5pt;
            }

            #display .hr div span.right::after {
                content: ' ';
                width: 100%;
                height: 0;
                vertical-align: middle;
                border-bottom: 1px solid var(--hr-color);
            }


            #display span.fmt {
                color: var(--inline-format-color);
            }
            #display span.bold {
                font-weight: bold;
            }
            #display span.italic {
                font-style: italic;
            }

            #display i.cursor {
                position: relative;
            }
            #display i.cursor::after {
                position: absolute;
                margin-left: -1pt;
                content: ' ';
                display: inline-block;
                height: 1em;
                bottom: 0;
                border-left: 2px solid black;

                animation-name: cursor;
                animation-duration: 2s;
                animation-iteration-count: infinite;
            }
            @keyframes cursor {
                20% { opacity: 1; }
                50% { opacity: 0; }
                80% { opacity: 1; }
            }


            #start-info {
                display: inline-block;
                position: relative;
                top: 50%;
                transform: translateY(-50%);
                width: 100%;
                text-align: center;
                font-style: italic;
            }
            #start-info h1 {
                color: #0001;
                font-size: 10vw;
            }
            #start-info p {
                padding: 10pt 0;
            }


            #settings {
                backdrop-filter: blur(2pt);
                background-color: #fffd;

                display: flex;
                flex-direction: column;
                padding: 10%;
            }
            #settings h2 {
                text-align: center;
                font-size: 200%;
                color: gray;
            }
            #settings textarea {
                flex-grow: 1;

                padding: 20pt;
                border: 1px solid #80808033;
                box-shadow: 3pt 3pt 10pt #80808066;
            }
            #controls-info {
                margin-top: 20pt;
            }
            #controls-info p {
                margin: 5pt 0 0;
            }
            #controls-info p.more {
                margin-top: 0;
            }
            #controls-info span {
                display: inline-block;
                width: 70pt;
                font-weight: bold;
                vertical-align: top;
            }
        </style>
        <script>
            let fileTypeDialogOption = { types: [{ description: 'Markdown', accept: { 'text/markdown': ['.md'] } }] };
            let scrollMargin = 50;
            let formats = {
                line: {
                    default:{ multiline: true },
                    h1:     { pattern: /^(#)($|\s+.*$)/ },
                    h2:     { pattern: /^(##)($|\s+.*$)/ },
                    h3:     { pattern: /^(###)($|\s+.*$)/ },
                    h4:     { pattern: /^(####)($|\s+.*$)/ },
                    h5:     { pattern: /^(#####)($|\s+.*$)/ },
                    h6:     { pattern: /^(######)($|\s+.*$)/ },
                    quote:  { pattern: /^(>)($|\s*.*$)/, multiline: true, outerTag: 'div' },
                    code:   { pattern: /^(```)($|\s*.*$)/, outerTag: 'code' },
                    ul:     { pattern: /^(-|\*)($|\s+.*$)/, multiline: true, listItem: true, outerTag: 'ul', innerTag: 'li' },
                    hr:     { pattern: /^(---)()$/, innerTag: 'div' }
                },
                inline: {
                    bold: [
                        { pattern: /((^|\s)(\*\*|__))\S/, splitAfter: 1, count: 2, start: true },
                        { pattern: /(\S(\*\*|__))\S/, splitAfter: 1, count: 2, toggle: true },
                        { pattern: /(\S(\*\*|__))(\s|$)/, splitAfter: 1, count: 2, end: true }],
                    italic: [
                        { pattern: /((^|\s)(\*|_))\S/, splitAfter: 1, count: 1, start: true },
                        { pattern: /(\S\*)\S/, splitAfter: 1, count: 1, toggle: true },
                        { pattern: /(\S(\*|_))(\s|$)/, splitAfter: 1, count: 1, end: true }
                    ]}};
            for (let f in formats.line) {
                formats.line[f].className = f;
                formats.line[f] = Object.assign({}, { match: { l: 1, r: 2 }, innerTag: 'p' }, formats.line[f]);
            }
            let lineFormats_all = Object.values(formats.line);
            let lineFormats_singleline = lineFormats_all.filter(f => !f.multiline);
            let lineFormats_listItem = lineFormats_all.filter(f => f.listItem);

            let inlineFormats = [];
            for (let f in formats.inline) {
                for (format of formats.inline[f]) {
                    format.className = f;
                    inlineFormats.push(format);
                }
            }

            let input = null;
            let display = null;
            let startInfo = null;
            let settings = null;
            let settingsInput = null;

            let docTitle = document.title;
            let customStyle = null;
            let currentFileHandle = null;
            let fileChanged = false;

            let sections = [];
            let selection = {};

            let cookies = Object.assign({}, ...document.cookie.split(';').map(c => { c = c.split('='); return { [c[0].trim()]: decodeURIComponent(c[1]) }; }));

            let inAppMode = window.matchMedia('(display-mode: standalone)').matches || window.matchMedia('(display-mode: minimal-ui)').matches;

            function init()
            {
                input = document.querySelector('#input');
                display = document.querySelector('#display');
                startInfo = document.querySelector('#start-info');
                settings = document.querySelector('#settings');
                settingsInput = settings.querySelector('textarea');

                // editor
                ['click', 'focus', 'select', 'keydown', 'keyup'].forEach(evt => input.addEventListener(evt, updateSelection));
                input.addEventListener('input', e => { fileChanged = !!input.value.length; updateMarkdown(); });
                updateMarkdown();
                display.addEventListener('click', e =>
                {
                    input.focus();
                });
                input.focus();

                // load/save local files
                let warningMsg = 'Changes to the current document will be lost.';
                document.addEventListener('dragover', e => e.preventDefault());
                document.addEventListener('drop', async e =>
                {
                    e.preventDefault();
                    if (fileChanged && !confirm(warningMsg + ' Proceed to open the dropped file?'))
                        return;
                    if (e.dataTransfer.items.length > 1) {
                        alert('Only a single file can be loaded.');
                        return;
                    }
                    let dataItem = e.dataTransfer.items[0];
                    if (dataItem.kind === 'file') {
                        currentFileHandle = await dataItem.getAsFileSystemHandle();
                        loadFile();
                    }
                });
                document.addEventListener('keydown', async e =>
                {
                    if (e.ctrlKey) {
                        switch (e.key.toLowerCase()) {
                            case 'o':
                                e.preventDefault();
                                if (fileChanged && !confirm(warningMsg + ' Proceed to open another file?'))
                                    return;
                                [currentFileHandle] = await window.showOpenFilePicker(fileTypeDialogOption);
                                loadFile();
                            break;
                            case 's':
                                e.preventDefault();
                                saveFile();
                            break;
                            case 'n':
                            case 'q':
                                e.preventDefault();
                                if (fileChanged && !confirm(warningMsg + ' Proceed to start a new file?'))
                                    return;
                                reset();
                                updateMarkdown();
                            break;
                            default:
                        }
                    }
                    if (e.key.toLowerCase() === 'escape') {
                        e.preventDefault();
                        toggleSettings();
                    }
                });
                window.addEventListener('beforeunload', e => {
                    if (fileChanged) {
                        e.preventDefault();
                        let msg = warningMsg + ' Close ' + docTitle + '?';
                        (e || window.event).returnValue = msg;
                        return msg;
                    }
                });

                // settings
                customStyle = new CSSStyleSheet();
                document.adoptedStyleSheets = [customStyle];
                if ('customStyle' in cookies)
                    settingsInput.value = cookies.customStyle;
                else {
                    let style = document.styleSheets[0].cssRules[0].styleMap;
                    let defaultStyle = '';
                    for (let key of style.keys()) {
                        defaultStyle += key + ':' + style.get(key) + ';\n';
                    }
                    settingsInput.value = defaultStyle;
                }
                settingsInput.addEventListener('input', e => {
                    applyCustomStyle();
                });
                applyCustomStyle();
            }
            function applyCustomStyle()
            {
                customStyle.replace(':root{' + settingsInput.value + '}');
            }
            function reset(clearFileHandle = true)
            {
                input.value = '';
                display.innerHTML = '';
                startInfo.classList.add('hidden');
                if (clearFileHandle) {
                    currentFileHandle = null;
                    document.title = docTitle;
                }
                fileChanged = false;
            }
            function toggleSettings()
            {
                settings.classList.toggle('hidden');
                if (!settings.classList.contains('hidden')) {
                    settingsInput.focus();
                }
                else {
                    document.cookie = 'customStyle=' + encodeURIComponent(settingsInput.value);
                    input.focus();
                }
            }
            async function loadFile()
            {
                if (currentFileHandle.kind !== 'file') {
                    currentFileHandle = null;
                    alert('Only files can be loaded.');
                    return;
                }
                if (!currentFileHandle.name.endsWith('.md')) {
                    currentFileHandle = null;
                    alert('Only Markdown (.md) files can be loaded.');
                    return;
                }
                console.log('try to load file: ' + currentFileHandle.name);
                let file = await currentFileHandle.getFile();
                let reader = new FileReader();
                reader.addEventListener('load', () => {
                    reset(false);
                    document.title = currentFileHandle.name + (!inAppMode ? ' - ' + docTitle : '');
                    input.value = reader.result;
                    updateMarkdown();
                    console.log('file loaded: ' + currentFileHandle.name);
                }, false);
                reader.readAsText(file);
            }
            async function saveFile()
            {
                if (!currentFileHandle) {
                    currentFileHandle = await window.showSaveFilePicker(fileTypeDialogOption);
                    if (!currentFileHandle) {
                        return;
                    }
                }
                let writableStream = await currentFileHandle.createWritable();
                await writableStream.write(input.value);
                await writableStream.close();
                fileChanged = false;
                document.title = currentFileHandle.name + (!inAppMode ? ' - ' + docTitle : '');
                console.log('file saved: ' + currentFileHandle.name);
            }
            function updateMarkdown()
            {
                display.innerHTML = '';

                if (input.value.length)
                    startInfo.classList.add('hidden');
                else {
                    startInfo.classList.remove('hidden');
                    return;
                }

                sections = [];
                let position = 0;
                let newSection = values => Object.assign({ pos: position, blankLinesPos: position, format: formats.line.default, content: [], blankLines: [] }, values);
                let lines = input.value.split('\n');

                // parse input text to get sections with line formats
                let startNewSection = true;
                lines.forEach(line =>
                {
                    let nextPosition = position + 1 + line.length;
                    line = { pos: position, text: line, left: '', right: line };
                    let lineFormatMatch = getLineFormat(line.text);
                    let prevSection = sections.length ? sections.last() : null;
                    let prevFormat = prevSection ? prevSection.format : null;

                    // code section
                    let prevIsCode = prevFormat && prevFormat === formats.line.code;
                    if (lineFormatMatch.format === formats.line.code && (!prevIsCode || !lineFormatMatch.match.r.trim().length)) {
                        line.left = lineFormatMatch.match.l;
                        line.right = lineFormatMatch.match.r;
                        if (!prevIsCode)
                            sections.push(newSection({ format: lineFormatMatch.format, content: [[line]], blankLinesPos: nextPosition }));
                        else {
                            prevSection.content.push([line]);
                            prevSection.finished = true;
                            startNewSection = true;
                            prevSection.blankLinesPos = nextPosition;
                        }
                    }
                    else if (prevIsCode && !prevSection.finished) {
                        prevSection.content.push([line]);
                        prevSection.blankLinesPos = nextPosition;
                    }

                    // empty line
                    else if (line.text.trim() === '') {
                        if (!sections.length)
                            sections.push(newSection({ blankLines: [line] }));
                        else
                            sections.last().blankLines.push(line);
                        startNewSection = true;
                    }
                    else {
                        line.left = lineFormatMatch.match.l;
                        line.right = lineFormatMatch.match.r;
                        // formatted
                        if (lineFormatMatch.format !== formats.line.default) {
                            let sameAsPrevious = prevFormat && prevFormat === lineFormatMatch.format && !prevSection.blankLines.length;
                            if (lineFormatMatch.format.listItem && sameAsPrevious) {
                                prevSection.content.push([line]);
                                startNewSection = false;
                            }
                            else if (lineFormatMatch.format.multiline && sameAsPrevious) {
                                prevSection.content.push([line]);
                                startNewSection = false;
                            }
                            else {
                                sections.push(newSection({ format: lineFormatMatch.format, content: [[line]] }));
                                startNewSection = lineFormats_singleline.includes(lineFormatMatch.format);
                            }
                        }
                        // plain text
                        else {
                            if (prevFormat && prevFormat.listItem && !prevSection.blankLines.length)
                                prevSection.content.last().push(line);
                            else if (startNewSection)
                                sections.push(newSection({ content: [[line]] }));
                            else
                                sections.last().content.push([line]);
                            startNewSection = false;
                        }
                        sections.last().blankLinesPos = nextPosition;
                    }
                    position = nextPosition;
                });
                // console.log(sections);

                // generate HTML
                sections.forEach(section =>
                {
                    let format = section.format;
                    section.htmlTag = document.createElement('div');
                    section.htmlTag.classList.add(format.className);

                    if (section.content.length) {
                        let container = section.htmlTag;
                        if (format.outerTag) {
                            container = document.createElement(format.outerTag);
                            section.htmlTag.appendChild(container);
                        }
                        for (let c in section.content) {
                            let lines = section.content[c];
                            let tag = document.createElement(format.innerTag);
                            for (let l in lines) {
                                let line = lines[l];
                                let spanLeft = document.createElement('span');
                                spanLeft.classList.add('left');
                                spanLeft.innerHTML = line.left;
                                tag.appendChild(spanLeft);

                                let spanRight = document.createElement('span');
                                spanRight.classList.add('right');
                                line.rightParts = detectInlineFormats(line);
                                for (let part of line.rightParts) {
                                    let spanPart = document.createElement('span');
                                    spanPart.className = part.classList.join(' ');
                                    spanPart.innerHTML = part.text;
                                    spanRight.appendChild(spanPart);
                                    part.htmlTag = spanPart;
                                }
                                tag.appendChild(spanRight);
                                line.htmlTag = spanRight;
                            }
                            container.appendChild(tag);
                            section.content[c] = { lines: lines, htmlTag: tag, pos: lines[0].pos };
                        }
                    }
                    if (section.blankLines.length) {
                        for (let c in section.blankLines) {
                            let line = section.blankLines[c];
                            let tag = document.createElement(formats.line.default.innerTag);
                                let spanLeft = document.createElement('span');
                                spanLeft.classList.add('left');
                                spanLeft.innerHTML = line.left;
                                tag.appendChild(spanLeft);

                                let spanRight = document.createElement('span');
                                spanRight.classList.add('right');
                                spanRight.innerHTML = line.text;
                                tag.appendChild(spanRight);
                                line.htmlTag = spanRight;
                            section.htmlTag.appendChild(tag);
                            section.blankLines[c] = { lines: [line], htmlTag: tag, pos: line.pos };
                        }
                    }
                    display.appendChild(section.htmlTag);
                });
                updateSelection();
            }
            function updateSelection()
            {
                if (!input.value.length)
                    return;

                document.querySelectorAll('#display .current').forEach(el => el.classList.remove('current'));
                display.querySelectorAll('.cursor').forEach(el => el.remove());

                let cursorPos = input.selectionStart;
                selection = {};

                // section
                for (let s in sections) {
                    let section = sections[s];
                    if (section.pos > cursorPos) {
                        selection.section = sections[s - 1];
                        break;
                    }
                }
                if (!selection.section)
                    selection.section = sections.last();
                selection.section.htmlTag.classList.add('current');

                // item/lines
                if (selection.section.blankLinesPos > cursorPos) {
                    for (let i in selection.section.content) {
                        let item = selection.section.content[i];
                        if (item.pos > cursorPos) {
                            selection.item = selection.section.content[i - 1];
                            break;
                        }
                    }
                    if (!selection.item)
                        selection.item = selection.section.content.last();
                    selection.item.htmlTag.classList.add('current');
                }

                // blank lines
                else {
                    for (let i in selection.section.blankLines) {
                        let item = selection.section.blankLines[i];
                        if (item.pos > cursorPos) {
                            selection.item = selection.section.blankLines[i - 1];
                            break;
                        }
                    }
                    if (!selection.item)
                        selection.item = selection.section.blankLines.last();
                    selection.item.htmlTag.classList.add('current');
                }

                // line
                for (let l in selection.item.lines) {
                    let line = selection.item.lines[l];
                    if (line.pos > cursorPos) {
                        selection.line = selection.item.lines[l - 1];
                        break;
                    }
                }
                if (!selection.line)
                    selection.line = selection.item.lines.last();
                selection.line.htmlTag.classList.add('current');

                // inline part
                if (selection.line.rightParts) {
                    for (let p in selection.line.rightParts) {
                        let part = selection.line.rightParts[p];
                        if (part.pos > cursorPos) {
                            selection.inlinePart = selection.line.rightParts[p - 1];
                            break;
                        }
                    }
                    if (!selection.inlinePart)
                        selection.inlinePart = selection.line.rightParts.last();
                    selection.inlinePart.htmlTag.classList.add('current');
                }

                // cursor
                let cp = selection.inlinePart || selection.line || selection.item; // cursor parent
                cp.htmlTag.innerHTML =  cp.htmlTag.innerHTML.substr(0, cursorPos - cp.pos) +
                                        '<i class="cursor"></i>' +
                                        cp.htmlTag.innerHTML.substr(cursorPos - cp.pos);

                // scroll to cursor if reqired
                let cursorBox = cp.htmlTag.getBoundingClientRect();
                if (cursorBox.top < scrollMargin) {
                    cp.htmlTag.scrollIntoView(true);
                    window.scrollBy(0, -scrollMargin);
                }
                else if (cursorBox.bottom > document.body.clientHeight - scrollMargin) {
                    cp.htmlTag.scrollIntoView(false);
                    window.scrollBy(0, scrollMargin);
                }
            }
            function getLineFormat(line, formatsToCheck = null)
            {
                let formatsArray = formatsToCheck || lineFormats_all;
                for (let i in formatsArray) {
                    let format = formatsArray[i];
                    if (!format.inline && format.pattern) {
                        let allMatches = line.match(format.pattern);
                        if (allMatches) {
                            let matches = {};
                            for (let m in format.match)
                                matches[m] = allMatches[format.match[m]];
                            return { format: format, match: matches };
                        }
                    }
                }
                return formatsToCheck ? null : { format: formats.line.default, match: { l: '', r: line } };
            }
            function detectInlineFormats(line)
            {
                let text = line.right;
                let position = line.pos;
                let parts = [];
                let active = {};
                while (true) {
                    let next = null;
                    for (let format of inlineFormats) {
                        let tmp = text.match(format.pattern);
                        if (tmp && (!next || (tmp.index < next.match.index) || (tmp.index === next.match.index && format.count > next.count)))
                            next = { match: tmp, format: format };
                    }
                    if (!next)
                        break;
                    let splitPos = next.match.index + next.match[next.format.splitAfter].length;
                    let part = text.substr(0, splitPos - next.format.count);
                    parts.push({ text: part, pos: position, classList: Object.keys(active) });
                    position += part.length;

                    part = text.substr(splitPos - next.format.count, next.format.count);
                    parts.push({ text: part, pos: position, classList: ['fmt'] });
                    position += next.format.count;

                    text = text.substr(splitPos);
                    if (next.format.start || (next.format.toggle && !active[next.format.className]))
                        active[next.format.className] = true;
                    else if (next.format.end || (next.format.toggle && active[next.format.className]))
                        delete active[next.format.className];
                }
                parts.push({ text: text, pos: position, classList: Object.keys(active) });
                return parts;
            }
            Object.defineProperty(Array.prototype, 'last', {
                value: function() { return this.length ? this[this.length - 1] : null; },
                enumerable: false
            });
        </script>
    </head>
    <body onload="init()">
        <div id="start-info" class="hidden">
            <p>Just start typing</p>
            <p>or press Ctrl+O or drop a file you want to edit</p>
            <p>or press Esc for settings</p>
            <h1>Instant Markdown</h1>
        </div>
        <textarea id="input"></textarea>
        <div id="display"></div>
        <div id="settings" class="hidden">
            <h2>Settings</h2>
            <textarea></textarea>
            <div id="controls-info">
                <p><span>Ctrl + O</span>Open a markdown file</p>
                <p><span>Ctrl + S</span>Save a markdown file</p>
                <p><span>Ctrl + Q</span>Start a fresh markdown file</p>
                <p class="more"><span>Ctrl + N</span>(only avilable in app mode)</p>
                <p><span>Escape</span>Toggle settings</p>
            </div>
        </div>
    </body>
</html>